--- ../Routing/Main.hs	2022-08-31 16:24:58.122447101 +0800
+++ Main.hs	2022-08-31 16:24:58.155448311 +0800
@@ -1,69 +1,102 @@
+{-# LANGUAGE LambdaCase #-}
+{-# LANGUAGE NamedFieldPuns #-}
 {-# LANGUAGE OverloadedStrings #-}
+{-# LANGUAGE ScopedTypeVariables #-}
 
+-- | Mimic a static site with concur replica.
+--
+-- Currently updates the URL as you move between pages,
+-- which allows you to use the back button.
+--
+-- WIP, and will eventually support:
+--
+-- + Going directly to pages by URL
+-- + Doing the rendering for initial pages on the server
 module Main where
 
-import Concur.Core (Widget, orr)
+import Concur.Core (Widget, liftSTM, orr)
+import Concur.Replica (runDefault)
+import Control.Concurrent.STM
 import Control.Monad.IO.Class (liftIO)
-import Control.Concurrent.Chan
-import Concur.Replica
-import Data.Maybe
-import Data.Text (Text, pack)
+import Data.Text (pack)
+import Network.Wai.Handler.Replica (Context(Context, call, registerCallback))
+import Prelude
 import Replica.VDOM (HTML)
 
-import Network.Wai.Handler.Replica as R
-
-import Prelude hiding (div)
+import qualified Concur.Replica.DOM as H
+import qualified Concur.Replica.DOM.Events as P
 
 class Route a where
   fromRoute :: String -> a
   toRoute :: a -> String
 
-route :: Route a => R.Context -> a -> (a -> Widget HTML (Either a b)) -> Widget HTML b
-route ctx a f = do
-  chan <- liftIO $ do
-    chan <- newChan :: IO (Chan String)
-    cb <- R.registerCallback ctx $ \hash -> writeChan chan hash
-    R.call ctx cb "window.onhashchange = function() { callCallback(arg, location.hash) };"
+data AppUpdate a b
+  = UpdateChangeUrl a
+  | UpdateExit b
+
+route :: forall a b. Route a => Context -> a -> (a -> Widget HTML (AppUpdate a b)) -> Widget HTML b
+route Context{call, registerCallback} initial f = do
+  chan <- liftIO newHistoryChan
+  go initial chan
+  where
+    newHistoryChan :: IO (TChan String)
+    newHistoryChan = do
+      chan <- newTChanIO
+      cb <- registerCallback $ \path -> atomically (writeTChan chan path)
+      call cb "window.onpopstate = function(event) { callCallback(arg, location.pathname); };"
     pure chan
 
-  go a chan
-
-  where
+    go :: a -> TChan String -> Widget HTML b
     go a chan = do
-      r <- orr [ Left <$> f a, Right <$> liftIO (readChan chan) ]
+      r <- orr [ Left <$> f a, Right <$> liftSTM (readTChan chan) ]
       case r of
-        Left (Left a') -> do
-          liftIO $ R.call ctx (toRoute a') "window.location.hash = '#' + arg;"
+        Left (UpdateChangeUrl a') -> do
+          liftIO $ call (toRoute a') "window.history.pushState({}, \"\", arg);"
           go a' chan
-        Left (Right b) -> pure b
-        Right a' -> go (fromRoute $ tail a') chan
+
+        Left (UpdateExit b) ->
+          pure b
+
+        Right path ->
+          go (fromRoute path) chan
 
 --------------------------------------------------------------------------------
 
 data State
-  = SiteA Int
+  = SiteA
   | SiteB String
   | SiteC Double
 
 instance Route State where
-  toRoute (SiteA a) = "a:" <> show a
-  toRoute (SiteB b) = "b:" <> b
-  toRoute (SiteC c) = "c:" <> show c
-
-  fromRoute ('a':':':a) = SiteA (read a)
-  fromRoute ('b':':':b) = SiteB b
-  fromRoute ('c':':':c) = SiteC (read c)
-
-routingApp :: State -> Widget HTML (Either State ())
-routingApp (SiteA a) = do
-  div [ onClick ] [ text ("Site A: " <> pack (show a)) ]
-  pure $ Left (SiteB "Next")
-routingApp (SiteB b) = do
-  div [ onClick ] [ text ("Site B: " <> pack (show b)) ]
-  pure $ Left (SiteC 66.6)
-routingApp (SiteC c) = do
-  div [ onClick ] [ text ("Site C: " <> pack (show c)) ]
-  pure $ Left (SiteA 666)
+  toRoute = \case
+    SiteA   -> "/"
+    SiteB b -> "/b-" <> b
+    SiteC c -> "/c-" <> show c
+
+  fromRoute = \case
+    "/"           -> SiteA
+    '/':'b':'-':b -> SiteB b
+    '/':'c':'-':c -> SiteC (read c)
+    _             -> error "Invalid URL"
+
+routingApp :: State -> Widget HTML (AppUpdate State ())
+routingApp = \case
+  SiteA -> do
+    _ <- H.div [ P.onClick ] [ H.text ("Site A (click for next site)") ]
+    pure $ UpdateChangeUrl (SiteB "Next")
+
+  SiteB b -> do
+    _ <- H.div [ P.onClick ] [ H.text ("Site B: " <> pack (show b)) ]
+    pure $ UpdateChangeUrl (SiteC 66.6)
+
+  SiteC c -> do
+    _ <- H.div [ P.onClick ] [ H.text ("Site C: " <> pack (show c)) ]
+    pure $ UpdateChangeUrl SiteA
 
 main :: IO ()
-main = runDefault 8080 "Select" $ \ctx -> route ctx (SiteA 0) routingApp
+main = do
+  putStrLn "Starting app"
+  runDefault 8080 "Website" $
+    \ctx -> do
+      liftIO (putStrLn "Client connected")
+      route ctx SiteA routingApp
